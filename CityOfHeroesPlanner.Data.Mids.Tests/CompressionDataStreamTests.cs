using ICSharpCode.SharpZipLib.Zip.Compression;
using ICSharpCode.SharpZipLib.Zip.Compression.Streams;
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Text;
using Xunit;

namespace CityOfHeroesPlanner.Data.Mids.Tests
{
    public class SaveStringTests
    {
        [Fact]
        public void CanDecompress()
        {
            // uc=1452&c=632&a=1264&f=HEX&dc=78DA6594D96E125118C7CF308394AD8516186A170A5DA02003442F5C63A2556F4AC552F512C7F6B4924C80303469AF4CEFEBD6363E8297BE8A8FE013B8DCBB8C1F7C7FB0E94C98FCE67CFB9243F5602DF4F9D1D15DA18CDFB74CDB6ED4B7BB66A723BBBE0DB3B7DF352DD17F7CF4CE0E358DAAB4A434B69A3DB3D5782ECD4EBB65A746CA35B92B5BB634EAFBFDD3A6DCB5E481B445A8D66E5BC63A59375B7B81C1A1DE9172273CF87CD8DC7BD52345904F56FF187DD0696E1BF7DA3B878DAA69F764F7304955ACD07BACF76B52E875BCE29747888A263CBFC13F4CED2FE8302B5FD401AB3EB80A4713116520BB1405A79863316631CE7CABC3857C14E41B43BE00F205902F847C09CAA3B28F5011E71DC5F1B2CCEB7D21D8DE648EBF04B799911D6625C775BFD7790BE4EBF11560034E828FC9C0CFBD79FCC83939CFBA1858239B20E204E1170313A04E36618E23C22AF7B341B20996A913985B02734B626E49CCED846A8DA2CFE80AFB5FCE8239E6EC2A9867160BCC4DCA33851EA68A5CCFFC0566C8268E1EE2A8791E5C009F908D8E383A7A5F1812B339A53AA751E734F69AC65ED3D86B1A7B5DC45EAF08DE479DE2CF20FE0CE22E0E89F80AD9CC717C65EE35CBF247CC33CA9D42EED4758EBD7483B97213BC05DEC68CEE30B7286E06BBC868F491D544D60BFAC031A64AB6CBB05D5E62D9EA32980573CC3AB596C35C739863FE023F858528A0EFC23166F206FC803B47390DE434505F09F595505F09F53D25DB32EE491939663581C7A11F3D22A58D6EAD937769CB2E49C525B9EA925C7349D65D929A36BAF9421948FC91D1BD76BE0548AB9CD7FE382F79C61D7E7759FDFC2F519533ECFE143CC1FFD547E6577D5493F30F4850DA70
            var compressionData = new CompressionData
            {
                // uc
                UncompressedByteCount = 1452,                
                // c
                CompressedByteCount = 632,
                // a
                EncodedByteCount = 1264,
                // dc
                EncodedString = "78DA6594D96E125118C7CF308394AD8516186A170A5DA02003442F5C63A2556F4AC552F512C7F6B4924C80303469AF4CEFEBD6363E8297BE8A8FE013B8DCBB8C1F7C7FB0E94C98FCE67CFB9243F5602DF4F9D1D15DA18CDFB74CDB6ED4B7BB66A723BBBE0DB3B7DF352DD17F7CF4CE0E358DAAB4A434B69A3DB3D5782ECD4EBB65A746CA35B92B5BB634EAFBFDD3A6DCB5E481B445A8D66E5BC63A59375B7B81C1A1DE9172273CF87CD8DC7BD52345904F56FF187DD0696E1BF7DA3B878DAA69F764F7304955ACD07BACF76B52E875BCE29747888A263CBFC13F4CED2FE8302B5FD401AB3EB80A4713116520BB1405A79863316631CE7CABC3857C14E41B43BE00F205902F847C09CAA3B28F5011E71DC5F1B2CCEB7D21D8DE648EBF04B799911D6625C775BFD7790BE4EBF11560034E828FC9C0CFBD79FCC83939CFBA1858239B20E204E1170313A04E36618E23C22AF7B341B20996A913985B02734B626E49CCED846A8DA2CFE80AFB5FCE8239E6EC2A9867160BCC4DCA33851EA68A5CCFFC0566C8268E1EE2A8791E5C009F908D8E383A7A5F1812B339A53AA751E734F69AC65ED3D86B1A7B5DC45EAF08DE479DE2CF20FE0CE22E0E89F80AD9CC717C65EE35CBF247CC33CA9D42EED4758EBD7483B97213BC05DEC68CEE30B7286E06BBC868F491D544D60BFAC031A64AB6CBB05D5E62D9EA32980573CC3AB596C35C739863FE023F858528A0EFC23166F206FC803B47390DE434505F09F595505F09F53D25DB32EE491939663581C7A11F3D22A58D6EAD937769CB2E49C525B9EA925C7349D65D929A36BAF9421948FC91D1BD76BE0548AB9CD7FE382F79C61D7E7759FDFC2F519533ECFE143CC1FFD547E6577D5493F30F4850DA70",
                // f
                Encoding = "HEX",
            };

            using (var compressionDataStream = new CompressionDataStream(compressionData))
            {
                Assert.True(ContainsMagicNumber(compressionDataStream));
            }            
        }

        private static readonly byte[] MagicNumber = new byte[4]
        {
            // M (ascii)
            0x4d,
            // x (ascii)
            0x78,
            // D (ascii)
            0x44,
            // 12 (decimal)
            0x0C,
        };

        private bool ContainsMagicNumber(Stream stream)
        {
            var bytes = new byte[MagicNumber.Length];
            var read = stream.Read(bytes, 0, bytes.Length);
            if (read != bytes.Length)
                return false;

            for (var i = 0; i < bytes.Length; i++)
            {
                if (i > bytes.Length - 4)
                    return false;
                if (bytes[i] == MagicNumber[0]
                    && bytes[i + 1] == MagicNumber[1]
                    && bytes[i + 2] == MagicNumber[2]
                    && bytes[i + 3] == MagicNumber[3])
                    return true;
            }
            return false;
        }
    }
}
